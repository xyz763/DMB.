// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract sms{

    struct Student{
        uint256 ID;
        string fname;
        uint256 marks1;
        uint256 marks2;
        }

        address owner;
        Student[] public students;
        uint256 public stdcount;
        

        modifier onlyowner(){
            require(owner==msg.sender," std no");
            _;
        }

        constructor(){
            owner=msg.sender;
        }

        function addstd(uint256 _ID, string memory _fname, uint256 _marks1, uint256 _marks2) public onlyowner {
            students.push(Student(_ID, _fname, _marks1, _marks2));//
            stdcount++;
        }

        function update(uint256 _ID, string memory _fname, uint256 _marks1, uint256 _marks2) public onlyowner {
            bool found= false;
            for (uint256 i=0; i<students.length;i++){
                if (students[i].ID == _ID){
                    students[i].fname=_fname;
                    students[i].marks1=_marks1;
                    students[i].marks2=_marks2;
                    found=true;
                    break;
                }
            }
            require(found,"STD no");
        }

        function bonus(uint256 _ID, uint256 _marks1, uint256 _marks2) public onlyowner {
            bool found=false;
            for(uint256 i=0; i<students.length;i++){
                if (students[i].ID == _ID){
                    students[i].marks1+=_marks1;
                    students[i].marks2 += _marks2;
                    found=true;
                    break;
                }
            }
            require(found," STD no");
        }

        function deletestd(uint256 _ID) onlyowner public {
            bool found=false;
            for (uint256 i=0; i<students.length;i++){
                if (students[i].ID == _ID){
                    students[i]=students[students.length-1];
                    students.pop();
                    stdcount--;
                    found=true;
                    break;
                }
            }
            require(found,"STD no");
        }

        function getbyid(uint256 _ID) onlyowner view public returns(Student memory){//
            for (uint256 i=0; i < students.length; i++){
                if (students[i].ID == _ID){
                    return students[i];
                }
            }
            revert("NO STD");
        }

        function getall() public view  onlyowner returns(Student[] memory){
            return students;
        }

        function total_marks(uint256 _ID) view onlyowner public returns(uint256){
             for (uint256 i=0; i<students.length;i++){
                if (students[i].ID == _ID){
                    uint256 total= students[i].marks1+students[i].marks2;
                    return total;
                }
                }
                revert("NO STD");
        }

        function persentage(uint256 _ID) view public onlyowner returns(uint256){
             for (uint256 i=0; i<students.length;i++){
                if (students[i].ID == _ID){
                   uint256 total= students[i].marks1+students[i].marks2;
                   uint256 persentages= (total * 100) / 200;
                   return persentages;
                }
                }
                revert("NO STD");
        }

    
    fallback() external payable{

    }

    receive() external payable { 

    }

    }
        